<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>SmartMouse_2018: ArgumentParser</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SmartMouse_2018
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classArgumentParser.html" title="A simple command-line argument parser based on the design of python&#39;s parser of the same name...">ArgumentParser</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A slimline C++ class for parsing command-line arguments, with an interface similar to python's class of the same name.</p>
<h2>Usage </h2>
<p>An example says it best: </p><pre class="fragment">int main(int argc, const char** argv) {

  // make a new ArgumentParser
  ArgumentParser parser;

  // add some arguments to search for
  parser.addArgument("-a");
  parser.addArgument("-b");
  parser.addArgument("-c", "--cactus", 1);
  parser.addArgument("-o", "--optional");
  parser.addArgument("-r", "--required", 1, true);
  parser.addArgument("--five", 5);
  parser.addArgument("--atleast", '+');
  parser.addArgument("--any", '*');
  parser.addFinalArgument("output");

  // parse the command-line arguments - throws if invalid format
  parser.parse(argc, argv);

  // if we get here, the configuration is valid
  int cactus = parser.retrieve&lt;int&gt;("cactus");
  return cactus;
}
</pre><p>If the supplied format is incorrect or we explicitly call <code>parser.usage()</code>, a usage string is printed to the terminal: </p><pre class="fragment">Usage: app_name --required REQUIRED [-a] [-b] [--optional] [--cactus CACTUS] 
                [--five FIVE FIVE FIVE ...] [--atleast ATLEAST [ATLEAST ...]]
                [--any [ANY ...]] output
</pre><h2>Compiling </h2>
<p>Just grab the <code><a class="el" href="argparse_8hpp.html">argparse.hpp</a></code> header and go! The <code><a class="el" href="classArgumentParser.html" title="A simple command-line argument parser based on the design of python&#39;s parser of the same name...">ArgumentParser</a></code> is the only definition in <code><a class="el" href="argparse_8hpp.html">argparse.hpp</a></code>. Dependent classes are nested within <code><a class="el" href="classArgumentParser.html" title="A simple command-line argument parser based on the design of python&#39;s parser of the same name...">ArgumentParser</a></code>.</p>
<h2>Format </h2>
<p><b>specifier</b> Arguments can be specified in a number of formats. They can have single character short names prefixed with a single '-': </p><pre class="fragment">-b
</pre><p>or long name prefixed with '&ndash;': </p><pre class="fragment">--banana
</pre><p><b>number</b> The number of expected inputs trailing an argument can also be specified. This comes in two flavours:</p>
<ol type="1">
<li>fixed number arguments</li>
<li>variable number arguments</li>
</ol>
<p>Fixed number arguments are simply specified with an integer which is <code>0</code> or greater. If that exact number of inputs trailing the argument is not found, the parser will fail with a <code>std::invalid_argument</code> exception. If the number is <code>1</code>, the input is stored as a string. If the number is greater than <code>1</code>, the input is stored as a vector of strings.</p>
<p>Variable number arguments allow for an undetermined number of inputs trailing an argument. The parser will attempt to consume as many arguments as possible until the next valid argument is encountered. There are two types of variable argument specifiers, and they use the same syntax as regular expressions:</p>
<ol type="1">
<li>`'+'<code>matches one or more inputs 2.</code>'*'` matches zero or more inputs</li>
</ol>
<p>In both cases, the output is stored as a vector of strings. If the number of inputs is not specified, it defaults to <code>0</code>.</p>
<p><b>required/optional</b> Arguments can be marked as either required or optional. All required arguments must appear before any optional arguments in the command-line input.</p>
<p><b>final</b> Often UNIX command-line tools have an un-named final argument that collects all remaining inputs. The name that these inputs map to internally can be specified using the <code>addFinalArgument()</code> method of <code><a class="el" href="classArgumentParser.html" title="A simple command-line argument parser based on the design of python&#39;s parser of the same name...">ArgumentParser</a></code>. Along with its name, you can also specify the number of inputs to parse. Since it is un-named however, there are a number of restrictions:</p>
<ol type="1">
<li>The final argument can always require a fixed number of inputs</li>
<li>If a fixed number of inputs is specified, it must be <code>1</code> or greater</li>
<li>The final argument can only take the `'+'` specifier if an argument with variadic number of inputs has not already been specified. This restiction exists because arguments do not have a fixed ordering and a variadic argument just before the final (un-named) argument will consume all of the reminaing arguments unless the final argument requires a fixed number of inputs</li>
</ol>
<h2>Retrieving </h2>
<p>Inputs to an argument can be retrieved with the <code>retrieve()</code> method of <code><a class="el" href="classArgumentParser.html" title="A simple command-line argument parser based on the design of python&#39;s parser of the same name...">ArgumentParser</a></code>. Importantly, if the inputs are parsed as an array, they must be retrieved as an array. Failure to do so will result in a <code>std::bad_cast</code> exception.</p>
<p>Arguments can also be cast to other types as long as the cast is trivial. For instance, we could retrieve the array of strings from the '&ndash;five' argument as an array of ints: </p><pre class="fragment">vector&lt;int&gt; five = parser.retrieve&lt;vector&lt;int&gt; &gt;("five");
</pre><p>or convert the required argument to a float: </p><pre class="fragment">float  req = parser.retrieve&lt;float&gt;("r");
</pre><h2>Method Summary </h2>
<pre class="fragment">ArgumentParser()      default constructor
useExceptions()       if true, parsing errors throw exceptions rather than printing to stderr and exiting
appName()             set the name of the application
addArgument()         specify an argument to search for
addFinalArgument()    specify a final un-named argument
ignoreFirstArgument() don't parse the first argument (usually the caller name on UNIX)
parse()               invoke the parser on a `char**` array
retrieve()            retrieve a set of inputs for an argument
usage()               return a formatted usage string
empty()               check if the set of specified arguments is empty
clear()               clear all specified arguments
exists()              check if an argument has been found
count()               count the number of inputs for an argument</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
